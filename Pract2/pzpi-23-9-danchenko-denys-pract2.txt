Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії





Звіт
до практичного завдання №2
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення: Self Encapsulate Field, Encapsulate Collection, Preserve Whole Object у мові С#»







Виконав:
ст. гр. ПЗПІ-23-9
Данченко Денис Олександрович
	                     Перевірив:
                     ст. викладач кафедри ПІ
                     Сокорчук Ігор Петрович	





Харків 2025
1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	26.11.2025	0.1	Початкова версія документу, заповнення всіх розділів






































2 ЗАВДАННЯ
1. Студент повинен обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
2. Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.
3. Кожен метод рефакторингу повинен супроводжуватись:
Описом проблеми, яку вирішує даний метод.
Кодом до і після застосування методу рефакторингу.
Поясненням переваг використаного методу.




















3 ОПИС ВИКОНАНОЇ РОБОТИ
  3.1 Вступ
У процесі розробки програмного забезпечення важливо не лише створити працездатний код, але й забезпечити його якість, читабельність, розширюваність та зручність супроводу. З часом навіть правильно спроектовані програми можуть ускладнюватися через додавання нового функціоналу, виправлення помилок та зміну вимог. У результаті код може ставати перевантаженим, заплутаним і важким для підтримки.
Рефакторинг є одним із ключових підходів до покращення якості програмного коду без зміни його зовнішньої поведінки. Він дозволяє усунути дублювання, спростити складну логіку, покращити структуру програми та підвищити її зрозумілість для інших розробників. Найбільш поширені та ефективні методи рефакторингу детально описані у книзі Мартіна Фаулера «Refactoring. Improving the Design of Existing Code».
3.2 Вибір методів рефакторингу
 Для практичної частини я обрав свій курсовий проект з першого курсу – гру Battle City. Переглянувши його повторно, я виявив типові проблеми якості програмного коду, що ускладнюють його супровід і розширення, та застосував три методи рефакторингу для їх усунення:
1. Self Encapsulate Field.
2. Encapsulate Collection .
3. Preserve Whole Object.
3.3 Метод 1: Self Encapsulate Field 
3.3.1 Опис проблеми
У класі Game координати гравця PlayerX та PlayerY використовуються як звичайні поля, до яких виконується прямий доступ у методі MovePlayer.
Це створює жорсткий зв’язок між логікою переміщення та внутрішньою реалізацією класу.

Проблеми такого підходу:
	неможливо легко додати перевірки або додаткову логіку при зміні координат;
	складніше змінити спосіб зберігання координат у майбутньому;
	знижується гнучкість та підтримуваність коду.
3.3.2 Суть методу 
Self Encapsulate Field  це метод рефакторингу, при якому:
	для поля створюється властивість (getter/setter);
	доступ до поля відбувається тільки через цю властивість, навіть усередині самого класу.
Це дозволяє контролювати зміну даних та зменшує залежність від внутрішньої реалізації.
3.3.3 Код до рефакторингу
1 public class Game
2 {
3   int PlayerX, PlayerY;
4   BaseElement[,] map;
5   Player player;
6
7   private void MovePlayer(int dX, int dY)
8   {
9       int newPlayerX = PlayerX + dX;
10      int newPlayerY = PlayerY + dY;
11
12      if (newPlayerX >= 0 && newPlayerX < map.GetLength(1) &&
13          newPlayerY >= 0 && newPlayerY < map.GetLength(0) &&
14          !(map[newPlayerY, newPlayerX] is Wall))
15      {
16          map[PlayerY, PlayerX] = new Empty();
17          PlayerX = newPlayerX;
18          PlayerY = newPlayerY;
19          map[PlayerY, PlayerX] = player;
20        }
21    }
22 }

          3.3.4 Пояснення обраного методу
Метод Self Encapsulate Field дозволяє:
	приховати прямий доступ до поля;

	керувати змінами значення через властивість;
	у майбутньому додати валідацію, логування або іншу логіку без зміни основного коду.
У цьому випадку поля PlayerX та PlayerY були інкапсульовані через властивості PlayerX і PlayerY.
3.3.5 Код після рефакторингу
1 public class Game
2 {
3   private int _playerX;
4   private int _playerY;
5   private BaseElement[,] map;
6
7   protected int PlayerX
8   {
9       get { return _playerX; }
10      set { _playerX = value; }
11  }
12
13  protected int PlayerY
14  {
15      get { return _playerY; }
16      set { _playerY = value; }
17  }
18
19  private void MovePlayer(int dX, int dY)
20  {
21      int newPlayerX = PlayerX + dX;
22      int newPlayerY = PlayerY + dY;
23
24      if (newPlayerX >= 0 && newPlayerX < map.GetLength(1) &&
25      newPlayerY >= 0 && newPlayerY < map.GetLength(0) &&
26      !(map[newPlayerY, newPlayerX] is Wall))
27      {
28          map[PlayerY, PlayerX] = new Empty();
29          PlayerX = newPlayerX;
30          PlayerY = newPlayerY;
31          map[PlayerY, PlayerX] = player;
32     }
33  }
34}


3.3.6 Переваги отриманого коду після застосування методу
1. Поля координат інкапсульовані, немає прямого доступу.
2. Можна додати перевірки в setter без зміни логіки руху.
3. Код став більш гнучким для модифікації.
4. Покращена підтримуваність та масштабованість.
5. Підготовка до можливого наслідування та розширення класу.
3.4 Метод 2: Encapsulate Collection
3.4.1 Опис проблеми 
          У класі Game для зберігання куль використовується колекція: private List<Bullet> bullets = new List<Bullet>();
У початковій реалізації метод ShootPlayer напряму додає нові елементи до цієї колекції через bullets.Add(bullet). Аналогічно, в інших методах відбувається напряму видалення елементів із цієї ж колекції.
Такий підхід створює низку проблем:
	внутрішня структура даних (List<Bullet>) стає частиною логіки класу;
	відсутній контроль над тим, як саме змінюється колекція;
	неможливо додати правила або обмеження;
	при зміні типу колекції потрібно буде змінювати багато коду.
Це знижує гнучкість, безпеку та підтримуваність програми.
3.4.2 Суть методу
Encapsulate Collection  це метод рефакторингу, при якому:
Колекція приховується всередині класу.
Зовнішньому коду не надається прямого доступу до List<T>.
Для роботи з колекцією надаються спеціальні методи.
Для читання використовується тільки IReadOnlyCollection<T>.
Це дозволяє контролювати доступ до колекції та зменшує залежність від конкретної реалізації.
3.4.3 Код до рефакторингу
1 public class Game
2 {
3     private List<Bullet> bullets = new List<Bullet>();
4     Player player;
5   int PlayerX, PlayerY;
6
7   private void ShootPlayer()
8   {
9       Bullet bullet = new Bullet
10      {
11          Direction = player.Direction,
12          X = PlayerX,
13          Y = PlayerY,
14          Speed = 1
15       };
16      bullets.Add(bullet);
17  }
18 } 


3.4.4 Пояснення обраного методу
Метод Encapsulate Collection дозволяє:
	відокремити логіку роботи з колекцією від бізнес-логіки гри;
	заборонити прямий доступ до внутрішнього списку;
	забезпечити контроль над тим, які саме операції виконуються з колекцією;
	зробити код менш залежним від конкретної реалізації структури даних.
3.4.5 Код після рефакторингу
1 public class Game
2 {
3    private readonly List<Bullet> _bullets = new List<Bullet>();
4    Player player;
5    int PlayerX, PlayerY;
6
7    protected IReadOnlyCollection<Bullet> Bullets
8    {
9        get { return _bullets.AsReadOnly(); }
10   }
11
12   protected void AddBullet(Bullet bullet)
13  {
14      _bullets.Add(bullet);
15  }
16
17  private void ShootPlayer()
18  {
19      Bullet bullet = new Bullet
20      {
21          Direction = player.Direction,
22          X = PlayerX,
23          Y = PlayerY,
24          Speed = 1
25      };
26      AddBullet(bullet);
27  }
28}

3.4.6 Переваги отриманого коду після застосування методу
1. Колекція bullets повністю інкапсульована всередині класу.
2. Всі зміни колекції відбуваються через спеціальний метод AddBullet.
3. Відсутній ризик випадкового очищення або пошкодження списку ззовні.
4. З’явилась можливість легко додати додаткову логіку: ліміт кількості куль, логування пострілів, перевірку стану гри перед пострілом.
5. Код став більш гнучким, безпечним та зручним для подальшого розвитку.
3.5 Метод 3: Preserve Whole Object
3.5.1 Опис проблеми
У початковій реалізації для пострілу ворога в метод ShootEnemy передавалися окремі частини стану об’єкта (enemyX, enemyY) замість передачі цілого об’єкта Enemy.
Такий підхід призводить до:
	надлишкової кількості параметрів у методах;
	жорсткого зв’язку між викликаючим кодом і внутрішнім станом об’єкта;
	ускладнення підтримки при зміні об’єкта доводиться змінювати сигнатури методів.
3.5.2 Суть методу
Preserve Whole Object це метод рефакторингу, при якому:
	замість передачі окремих властивостей об’єкта (наприклад, x, y),
	передається весь об’єкт повністю;
	потрібні дані витягуються всередині методу.
	Це зменшує кількість параметрів, робить код гнучкішим та менш зв’язаним.
3.5.3 Код до рефакторингу
1 private void EnemyShootTimer_Tick(object sender, EventArgs eventArgs)
2 {
3   foreach (var enemy in enemies)
4   {
5       int enemyX = GetXPosition(enemy);
6       int enemyY = GetYPosition(enemy);
7
8       ShootEnemy(enemy, enemyX, enemyY);
9    }
10}
11
12 private void ShootEnemy(Enemy enemy, int enemyX, int enemyY)
13{
14   string direction = DirectionPlayer(enemy);
15
16   var bullet = new Bullet
17   {
18      Direction = direction,
19      X = enemyX,
20      Y = enemyY,
21      Speed = 1
22   };
23   bullets.Add(bullet);
24}

3.5.4 Пояснення обраного методу
Метод Preserve Whole Object дозволяє:
уникнути передачі частин одного й того ж об’єкта як окремих параметрів;
зменшити кількість аргументів у методах;
зберегти цілісність об’єкта при передачі між методами;
підвищити гнучкість при зміні структури об’єкта.


3.5.5 Код після рефакторингу
1 private void EnemyShootTimer_Tick(object sender, EventArgs eventArgs)
2 {
3    foreach (var enemy in enemies)
4    {
5        ShootEnemy(enemy); 
6    }
7 }
8
9  private void ShootEnemy(Enemy enemy)
10 {
11  string direction = DirectionPlayer(enemy);
12
13  int enemyX = GetXPosition(enemy);
14  int enemyY = GetYPosition(enemy);
15
16  var bullet = new Bullet
17   {
18      Direction = direction,
19      X = enemyX,
20      Y = enemyY,
21      Speed = 1
22   };
23   bullets.Add(bullet);
24 }

3.5.6 Переваги отриманого коду після застосування методу
Менша кількість параметрів у методах.
Код став менш зв’язаним із внутрішньою структурою об’єкта Enemy.
Легше змінювати структуру класу Enemy без змін сигнатур методів.
Підвищена читабельність та зрозумілість коду.
Збережена цілісність даних об’єкта при передачі між методами.
3.6 Інструменти автоматизації рефакторингу (Visual Studio)
3.6.1 Безпечне перейменування (Rename)
Замість того, щоб вручну шукати та змінювати назву змінної, методу або класу, у Visual Studio використовується функція Rename. Цей інструмент автоматично змінює ім’я вибраного елемента у всьому проекті, інтелектуально враховуючи контекст використання. Завдяки цьому виключаються помилки, пов’язані з неповним або неправильним перейменуванням.
3.6.2 Вбудований аналізатор коду (Code Analysis)
Вбудований аналізатор коду в Visual Studio автоматично перевіряє програмний код під час його написання. Він знаходить логічні помилки, потенційно небезпечні місця, зайві змінні та методи, а також порушення стандартів програмування. Проблемні ділянки підсвічуються, а середовище пропонує швидкі виправлення. Це дозволяє значно підвищити якість коду та зменшити кількість помилок ще на етапі розробки.
3.6.3 Виділення методу (Extract Method)
Функція Extract Method використовується для того, щоб виділити частину довгого або перевантаженого методу в окремий новий метод. Для цього достатньо виділити потрібний фрагмент коду, викликати меню швидких дій Ctrl + . або Ctrl + R, M та обрати пункт Extract Method. Visual Studio автоматично створює новий метод, передає йому всі необхідні параметри та замінює старий код його викликом. Це значно покращує читабельність, структуру та підтримуваність програмного забезпечення.
3.6.4 Move to File переміщення класу у новий файл
Інструмент Move to File дозволяє швидко та безпечно перемістити клас у новий окремий файл. Для цього потрібно викликати меню швидких дій на назві класу та обрати пункт Move to file. Visual Studio автоматично створює новий файл, переносить у нього клас, а також оновлює всі необхідні посилання, using та namespace. Цей інструмент використовується для впорядкування структури проєкту та покращення його архітектури.
3.6.5 Extract Interface, Extract Base Class
Інструмент Extract Interface дозволяє автоматично створити інтерфейс з уже існуючого класу. Visual Studio переносить у нього обрані публічні методи та підключає створений інтерфейс до класу. Це зменшує залежності між компонентами, покращує тестованість і дозволяє реалізовувати принцип інверсії залежностей.
Інструмент Extract Base Class, у свою чергу, дозволяє винести спільну логіку кількох класів у новий базовий клас. При цьому Visual Studio автоматично переносить спільні поля та методи і підключає спадкування. Це допомагає усунути дублювання коду та підвищити масштабованість проекту.


4 ВИСНОВКИ
У процесі виконання даної практичної роботи було розглянуто сутність та практичне значення рефакторингу програмного коду як важливого етапу життєвого циклу програмного забезпечення. Було встановлено, що рефакторинг дозволяє суттєво покращити структуру програмного коду без зміни його зовнішньої поведінки, підвищити читабельність, зменшити зв’язність між компонентами та забезпечити зручність подальшого супроводу й розвитку програмного продукту. Для практичної реалізації було використано власний курсовий проект гру Battle City, у межах якого проаналізовано типові недоліки побудови програмного коду та застосовано три методи рефакторингу з книги Мартіна Фаулера: Self Encapsulate Field, Encapsulate Collection та Preserve Whole Object. У результаті їх використання програмний код став більш структурованим, гнучким, зрозумілим та зручним для супроводу. Також було розглянуто можливості автоматизації рефакторингу за допомогою середовища Visual Studio, яке значно спрощує виконання таких операцій, як перейменування, виділення методів, створення інтерфейсів, переміщення класів у нові файли та форматування коду. Отже, дана робота дозволила на практиці закріпити навички аналізу програмного коду, правильного вибору методів рефакторингу та використання сучасних інструментів їх автоматизації.










5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. Self Encapsulate Field. Refactoring and Design Patterns. URL: https://refactoring.guru/self-encapsulate-field (дата звернення: 26.11.2025).
2. Encapsulate Collection. Refactoring and Design Patterns. URL: https://refactoring.guru/encapsulate-collection (дата звернення: 26.11.2025).
3. Preserve Whole Object. Refactoring and Design Patterns. URL: https://refactoring.guru/preserve-whole-object (дата звернення: 26.11.2025).
4.  Fowler, M. Refactoring. Improving the Design of Existing Code. – Boston : Addison-Wesley, 2018.
5. Refactor a field to a property - Visual Studio (Windows). Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/visualstudio/ide/reference/encapsulate-field?view=visualstudio (дата звернення: 26.11.2025).















ДОДАТОК А
А.1 Відеозапис
	Відеозапис доповіді: https://youtu.be/ZSKTN9iio-E
	Хронологічний опис відео:
	00:00 – Назва теми доповіді 
00:12 – Вступна частина 
00:40 – Обрані методи 
01:22 – Метод «Self Encapsulate Field», опис проблеми 
02:04 – Метод «Self Encapsulate Field», рішення 
02:33 – Метод «Encapsulate Collection», опис проблеми 
03:04 – Метод «Encapsulate Collection», рішення 
03:35 – Метод «Preserve Whole Object», опис проблеми 
04:05 – Метод «Preserve Whole Object», рішення 
04:37 – Інструменти рефакторингу Visual Studio 
05:55 – Висновок





ДОДАТОК Б
	Б.1 Слайди презентації
 
Рисунок Б.1 – Титульний слайд

 
Рисунок Б.2 – Вступ

 
Рисунок Б.3 – Використані методи 

 
Рисунок Б.4 – Метод «Self Encapsulate Field», опис проблеми

 
Рисунок Б.5 – Метод «Self Encapsulate Field», рішення

 
Рисунок Б.6 – Метод «Encapsulate Collection», опис проблеми

 
Рисунок Б.7 – Метод «Encapsulate Collection», рішення

 
Рисунок Б.8 – Метод «Preserve Whole Object», опис проблеми

 
Рисунок Б.9 – Метод «Preserve Whole Object», рішення

 
Рисунок Б.10 – Інструменти рефакторингу Visual Studio

 
Рисунок Б.11 – Висновок


















ДОДАТОК В
В.1 Програмний код
Посилання на репозиторій проекту: 
https://github.com/9Denys/game-laboratory-work-/tree/main/BattleCity12/BattleCity12

